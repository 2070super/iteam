; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\adc.o --asm_dir=.\ --list_dir=.\ --depend=.\adc.d --apcs=interwork -O0 --diag_suppress=9931 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\Philips -D__UVISION_VERSION=514 --omf_browse=.\adc.crf ADC.C]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Delayms PROC
;;;9      ****************************************************************************/
;;;10     void  Delayms(uint32  dly)
000000  ea000006          B        |L1.32|
                  |L1.4|
;;;11     {
;;;12        uint32  i;
;;;13        for(; dly>0; dly--)
;;;14        for(i=0; i<50000; i++);
000004  e3a01000          MOV      r1,#0
000008  ea000000          B        |L1.16|
                  |L1.12|
00000c  e2811001          ADD      r1,r1,#1
                  |L1.16|
000010  e59f22cc          LDR      r2,|L1.740|
000014  e1510002          CMP      r1,r2
000018  3afffffb          BCC      |L1.12|
00001c  e2400001          SUB      r0,r0,#1              ;13
                  |L1.32|
000020  e3500000          CMP      r0,#0                 ;13
000024  1afffff6          BNE      |L1.4|
;;;15     }
000028  e12fff1e          BX       lr
;;;16     #define S0SPCR           (*((volatile unsigned char *) 0xE0020000))      /* no in lpc210x*/
                          ENDP

                  UART0_Init PROC
;;;25     ****************************************************************************/
;;;26     void  UART0_Init(void)
00002c  e3a01083          MOV      r1,#0x83
;;;27     {
;;;28        uint16  Fdiv;
;;;29     
;;;30        U0LCR = 0x83;		             // DLAB = 1，可设置波特率
000030  e59f22b0          LDR      r2,|L1.744|
000034  e5c2100c          STRB     r1,[r2,#0xc]
;;;31        Fdiv = (Fpclk / 16) / UART_BPS;           // 设置波特率
000038  e3a000c3          MOV      r0,#0xc3
;;;32        U0DLM = Fdiv / 256;							
00003c  e1a01000          MOV      r1,r0
000040  e1a02fc0          ASR      r2,r0,#31
000044  e0802c22          ADD      r2,r0,r2,LSR #24
000048  e1a02442          ASR      r2,r2,#8
00004c  e59f3294          LDR      r3,|L1.744|
000050  e5c32004          STRB     r2,[r3,#4]
;;;33        U0DLL = Fdiv % 256;						
000054  e1a01000          MOV      r1,r0
000058  e1a02fc0          ASR      r2,r0,#31
00005c  e0802c22          ADD      r2,r0,r2,LSR #24
000060  e1a02442          ASR      r2,r2,#8
000064  e0402402          SUB      r2,r0,r2,LSL #8
000068  e5c32000          STRB     r2,[r3,#0]
;;;34        U0LCR = 0x03;
00006c  e3a01003          MOV      r1,#3
000070  e1c32000          BIC      r2,r3,r0
000074  e5c2100c          STRB     r1,[r2,#0xc]
;;;35     }
000078  e12fff1e          BX       lr
;;;36     				
                          ENDP

                  UART0_SendByte PROC
;;;43     ****************************************************************************/
;;;44     void  UART0_SendByte(uint8 data)
00007c  e59f1264          LDR      r1,|L1.744|
;;;45     {
;;;46     
;;;47       U0THR = data;				     // 发送数据
000080  e5c10000          STRB     r0,[r1,#0]
;;;48       while( (U0LSR&0x40)==0 );	             // 等待数据发送完毕
000084  e1a00000          MOV      r0,r0
                  |L1.136|
000088  e59f1258          LDR      r1,|L1.744|
00008c  e5d11014          LDRB     r1,[r1,#0x14]
000090  e2011040          AND      r1,r1,#0x40
000094  e3510000          CMP      r1,#0
000098  0afffffa          BEQ      |L1.136|
;;;49     }
00009c  e12fff1e          BX       lr
;;;50     
                          ENDP

                  ISendStr PROC
;;;56     ****************************************************************************/
;;;57     void  ISendStr(char *str)
0000a0  e52de004          PUSH     {lr}
;;;58     {  while(1)
0000a4  e1a02000          MOV      r2,r0
0000a8  ea000005          B        |L1.196|
                  |L1.172|
;;;59        {  if(*str=='\0') break;                  // 若为'\0'，则退出
0000ac  e5d20000          LDRB     r0,[r2,#0]
0000b0  e3500000          CMP      r0,#0
0000b4  1a000000          BNE      |L1.188|
0000b8  ea000002          B        |L1.200|
                  |L1.188|
;;;60           UART0_SendByte(*str++);                // 发送显示数据
0000bc  e4d20001          LDRB     r0,[r2],#1
0000c0  ebfffffe          BL       UART0_SendByte
                  |L1.196|
0000c4  eafffff8          B        |L1.172|
                  |L1.200|
0000c8  e1a00000          MOV      r0,r0                 ;59
;;;61        }
;;;62     }
0000cc  e49de004          POP      {lr}
0000d0  e12fff1e          BX       lr
;;;63     #if 1
                          ENDP

                  MSpiIni PROC
;;;69     ****************************************************************************/
;;;70     void  MSpiIni(void)
0000d4  e3a00052          MOV      r0,#0x52
;;;71     {
;;;72        S0SPCCR = 0x52;			     // 设置SPI时钟分频
0000d8  e59f120c          LDR      r1,|L1.748|
0000dc  e5c1000c          STRB     r0,[r1,#0xc]
;;;73        S0SPCR = 0x20;		             // 设置SPI接口模式，MSTR=1，CPOL=1，CPHA=0，LSBF=0
0000e0  e3a00020          MOV      r0,#0x20
0000e4  e5c10000          STRB     r0,[r1,#0]
;;;74     }
0000e8  e12fff1e          BX       lr
;;;75     
                          ENDP

                  MSendData PROC
;;;82     ****************************************************************************/
;;;83     uint8  MSendData(uint8 data)
0000ec  e1a01000          MOV      r1,r0
;;;84     {
;;;85        uint8 temp = S0SPDR;
0000f0  e59f01f4          LDR      r0,|L1.748|
0000f4  e5d02008          LDRB     r2,[r0,#8]
;;;86     
;;;87        IO0CLR = HC595_CS;			        // 片选
0000f8  e3a00202          MOV      r0,#0x20000000
0000fc  e59f31ec          LDR      r3,|L1.752|
000100  e583000c          STR      r0,[r3,#0xc]
;;;88     
;;;89        S0SPDR = data;
000104  e0600640          RSB      r0,r0,r0,ASR #12
000108  e5c01008          STRB     r1,[r0,#8]
;;;90        while( 0==(S0SPSR&0x80) );		        // 等待SPIF置位，即等待数据发送完毕
00010c  e1a00000          MOV      r0,r0
                  |L1.272|
000110  e59f01d4          LDR      r0,|L1.748|
000114  e5d00004          LDRB     r0,[r0,#4]
000118  e2000080          AND      r0,r0,#0x80
00011c  e3500000          CMP      r0,#0
000120  0afffffa          BEQ      |L1.272|
;;;91     
;;;92        IO0SET = HC595_CS;
000124  e3a00202          MOV      r0,#0x20000000
000128  e59f31c0          LDR      r3,|L1.752|
00012c  e5830004          STR      r0,[r3,#4]
;;;93        return(S0SPDR);
000130  e0600640          RSB      r0,r0,r0,ASR #12
000134  e5d00008          LDRB     r0,[r0,#8]
;;;94     }
000138  e12fff1e          BX       lr
;;;95     #endif
                          ENDP

                  main PROC
;;;106    ****************************************************************************/
;;;107     int main(void)
00013c  e24dd018          SUB      sp,sp,#0x18
;;;108    {
;;;109       uint32  ADC_Data;
;;;110       char    str[20];
;;;111       PINSEL0 = 0x00001505;            			 // 设置P0.0、P0.1连接到UART0的TXD、RXD
000140  e59f01ac          LDR      r0,|L1.756|
000144  e59f11ac          LDR      r1,|L1.760|
000148  e5810000          STR      r0,[r1,#0]
;;;112       PINSEL1 = 0x01000000;		        	 // 设置P0.28连接到AIN1
00014c  e3a00401          MOV      r0,#0x1000000
000150  e5810004          STR      r0,[r1,#4]
;;;113       IO0DIR = HC595_CS;				         // 设置HC595_CS控制口为输出
000154  e3a00202          MOV      r0,#0x20000000
000158  e1c117c0          BIC      r1,r1,r0,ASR #15
00015c  e5810008          STR      r0,[r1,#8]
;;;114       UART0_Init();					 // 初始化UART0
000160  ebfffffe          BL       UART0_Init
;;;115       MSpiIni();                                            // 初始化SPI接口
000164  ebfffffe          BL       MSpiIni
;;;116    
;;;117       /* 进行ADC模块设置，其中x<<n表示第n位设置为x(若x超过一位，则向高位顺延) */
;;;118       ADCR = (1 << 1)                    |		 // SEL = 1 ，选择通道0
000168  e59f018c          LDR      r0,|L1.764|
00016c  e59f118c          LDR      r1,|L1.768|
000170  e5810000          STR      r0,[r1,#0]
;;;119              ((Fpclk / 1000000 - 1) << 8) | 		 // CLKDIV = Fpclk / 1000000 - 1 ，即转换时钟为1MHz
;;;120              (0 << 16)                    |		 // BURST = 0 ，软件控制转换操作
;;;121              (0 << 17)                    | 		 // CLKS = 0 ，使用11clock转换
;;;122              (1 << 21)                    | 		 // PDN = 1 ， 正常工作模式(非掉电转换模式)
;;;123              (0 << 22)                    | 		 // TEST1:0 = 00 ，正常工作模式(非测试模式)
;;;124              (1 << 24)                    | 		 // START = 1 ，直接启动ADC转换
;;;125              (0 << 27);				         // EDGE = 0 (CAP/MAT引脚下降沿触发ADC转换)
;;;126       Delayms(10);								
000174  e3a0000a          MOV      r0,#0xa
000178  ebfffffe          BL       Delayms
;;;127       ADC_Data = ADDR;					 // 读取ADC结果，并清除DONE标志位
00017c  e59f017c          LDR      r0,|L1.768|
000180  e5900004          LDR      r0,[r0,#4]
;;;128    
;;;129       while(1)
000184  ea000055          B        |L1.736|
                  |L1.392|
;;;130       {
;;;131          ADCR = (ADCR&0xFFFFFF00)|0x02|(1 << 24);	 // 切换通道并进行第一次转换
000188  e59f0170          LDR      r0,|L1.768|
00018c  e5900000          LDR      r0,[r0,#0]
000190  e3c000ff          BIC      r0,r0,#0xff
000194  e3800401          ORR      r0,r0,#0x1000000
000198  e3800002          ORR      r0,r0,#2
00019c  e59f115c          LDR      r1,|L1.768|
0001a0  e5810000          STR      r0,[r1,#0]
;;;132          while( (ADDR&0x80000000)==0 );			 // 等待转换结束
0001a4  e1a00000          MOV      r0,r0
                  |L1.424|
0001a8  e59f0150          LDR      r0,|L1.768|
0001ac  e5900004          LDR      r0,[r0,#4]
0001b0  e2000102          AND      r0,r0,#0x80000000
0001b4  e3500000          CMP      r0,#0
0001b8  0afffffa          BEQ      |L1.424|
;;;133          ADCR = ADCR | (1 << 24);			 // 再次启运转换
0001bc  e59f013c          LDR      r0,|L1.768|
0001c0  e5900000          LDR      r0,[r0,#0]
0001c4  e3800401          ORR      r0,r0,#0x1000000
0001c8  e59f1130          LDR      r1,|L1.768|
0001cc  e5810000          STR      r0,[r1,#0]
;;;134          while( (ADDR&0x80000000)==0 );
0001d0  e1a00000          MOV      r0,r0
                  |L1.468|
0001d4  e59f0124          LDR      r0,|L1.768|
0001d8  e5900004          LDR      r0,[r0,#4]
0001dc  e2000102          AND      r0,r0,#0x80000000
0001e0  e3500000          CMP      r0,#0
0001e4  0afffffa          BEQ      |L1.468|
;;;135          ADC_Data = ADDR;					 // 读取ADC结果
0001e8  e59f0110          LDR      r0,|L1.768|
0001ec  e5904004          LDR      r4,[r0,#4]
;;;136          ADC_Data = (ADC_Data>>6) & 0x3FF;
0001f0  e1e009c0          MVN      r0,r0,ASR #19
0001f4  e0004324          AND      r4,r0,r4,LSR #6
;;;137          ADC_Data = ADC_Data * 3300;
0001f8  e59f0104          LDR      r0,|L1.772|
0001fc  e0040490          MUL      r4,r0,r4
;;;138          ADC_Data = ADC_Data / 1024;
000200  e1a04524          LSR      r4,r4,#10
;;;139          sprintf(str, "VIN1=%4dmV \r\n", ADC_Data);
000204  e1a02004          MOV      r2,r4
000208  e28f10f8          ADR      r1,|L1.776|
00020c  e28d0004          ADD      r0,sp,#4
000210  ebfffffe          BL       __2sprintf
;;;140          ISendStr(str);                                     // 从串口中输出结果
000214  e28d0004          ADD      r0,sp,#4
000218  ebfffffe          BL       ISendStr
;;;141          MSendData(~DISP_TAB[ADC_Data % 10]);	         //  发送显示数据个位
00021c  e3a0100a          MOV      r1,#0xa
000220  e1a00004          MOV      r0,r4
000224  ebfffffe          BL       __aeabi_uidivmod
000228  e59f00e8          LDR      r0,|L1.792|
00022c  e7d00001          LDRB     r0,[r0,r1]
000230  e1e00000          MVN      r0,r0
000234  e20050ff          AND      r5,r0,#0xff
000238  e1a00005          MOV      r0,r5
00023c  ebfffffe          BL       MSendData
;;;142          MSendData(~DISP_TAB[ADC_Data % 100 / 10]);	         //  发送显示数据十位
000240  e3a01064          MOV      r1,#0x64
000244  e1a00004          MOV      r0,r4
000248  ebfffffe          BL       __aeabi_uidivmod
00024c  e1a06001          MOV      r6,r1
000250  e3a0100a          MOV      r1,#0xa
000254  e1a00006          MOV      r0,r6
000258  ebfffffe          BL       __aeabi_uidivmod
00025c  e59f10b4          LDR      r1,|L1.792|
000260  e7d10000          LDRB     r0,[r1,r0]
000264  e1e00000          MVN      r0,r0
000268  e20050ff          AND      r5,r0,#0xff
00026c  e1a00005          MOV      r0,r5
000270  ebfffffe          BL       MSendData
;;;143          MSendData(~DISP_TAB[ADC_Data % 1000 / 100]);	 //  发送显示数据百位
000274  e3a01ffa          MOV      r1,#0x3e8
000278  e1a00004          MOV      r0,r4
00027c  ebfffffe          BL       __aeabi_uidivmod
000280  e1a06001          MOV      r6,r1
000284  e3a01064          MOV      r1,#0x64
000288  e1a00006          MOV      r0,r6
00028c  ebfffffe          BL       __aeabi_uidivmod
000290  e59f1080          LDR      r1,|L1.792|
000294  e7d10000          LDRB     r0,[r1,r0]
000298  e1e00000          MVN      r0,r0
00029c  e20050ff          AND      r5,r0,#0xff
0002a0  e1a00005          MOV      r0,r5
0002a4  ebfffffe          BL       MSendData
;;;144          MSendData(~DISP_TAB[ADC_Data / 1000 % 10]);	 //  发送显示数据千位
0002a8  e3a01ffa          MOV      r1,#0x3e8
0002ac  e1a00004          MOV      r0,r4
0002b0  ebfffffe          BL       __aeabi_uidivmod
0002b4  e1a06000          MOV      r6,r0
0002b8  e3a0100a          MOV      r1,#0xa
0002bc  ebfffffe          BL       __aeabi_uidivmod
0002c0  e59f0050          LDR      r0,|L1.792|
0002c4  e7d00001          LDRB     r0,[r0,r1]
0002c8  e1e00000          MVN      r0,r0
0002cc  e20050ff          AND      r5,r0,#0xff
0002d0  e1a00005          MOV      r0,r5
0002d4  ebfffffe          BL       MSendData
;;;145          Delayms(200);
0002d8  e3a000c8          MOV      r0,#0xc8
0002dc  ebfffffe          BL       Delayms
                  |L1.736|
0002e0  eaffffa8          B        |L1.392|
;;;146    
;;;147    	  }
;;;148    
;;;149    
;;;150    }
;;;151    
                          ENDP

                  |L1.740|
                          DCD      0x0000c350
                  |L1.744|
                          DCD      0xe000c000
                  |L1.748|
                          DCD      0xe0020000
                  |L1.752|
                          DCD      0xe0028000
                  |L1.756|
                          DCD      0x00001505
                  |L1.760|
                          DCD      0xe002c000
                  |L1.764|
                          DCD      0x01201d02
                  |L1.768|
                          DCD      0xe0034000
                  |L1.772|
                          DCD      0x00000ce4
                  |L1.776|
000308  56494e31          DCB      "VIN1=%4dmV \r\n",0
00030c  3d253464
000310  6d56200d
000314  0a00    
000316  00                DCB      0
000317  00                DCB      0
                  |L1.792|
                          DCD      DISP_TAB

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DISP_TAB
000000  c0f9a4b0          DCB      0xc0,0xf9,0xa4,0xb0
000004  999282f8          DCB      0x99,0x92,0x82,0xf8
000008  80908883          DCB      0x80,0x90,0x88,0x83
00000c  c6a1868e          DCB      0xc6,0xa1,0x86,0x8e

                  __ARM_use_no_argv EQU 0
